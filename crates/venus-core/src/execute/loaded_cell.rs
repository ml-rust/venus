//! Loaded cell management.
//!
//! Handles loading compiled cell dynamic libraries and keeping them
//! alive for execution.

use libloading::Library;

use crate::compile::CompiledCell;
use crate::error::{Error, Result};

/// A loaded cell library ready for execution.
pub struct LoadedCell {
    /// The compiled cell metadata
    pub compiled: CompiledCell,
    /// The loaded dynamic library (kept alive for symbol validity)
    pub(crate) library: Library,
    /// Number of dependencies (for FFI call construction)
    pub(crate) dep_count: usize,
}

impl LoadedCell {
    /// Load a compiled cell's dynamic library.
    ///
    /// # Arguments
    /// * `compiled` - The compiled cell metadata with dylib path
    /// * `dep_count` - Number of dependencies (for FFI dispatch)
    ///
    /// # Safety
    /// Trusts that the compiled cell was generated by our compiler
    /// and has the correct entry point signature.
    pub fn load(compiled: CompiledCell, dep_count: usize) -> Result<Self> {
        // Safety: We trust the compiled cell was generated by our compiler
        let library = unsafe { Library::new(&compiled.dylib_path) }.map_err(|e| {
            Error::Execution(format!(
                "Failed to load cell library {}: {}",
                compiled.dylib_path.display(),
                e
            ))
        })?;

        Ok(Self {
            compiled,
            library,
            dep_count,
        })
    }

    /// Get the cell's entry symbol name.
    pub fn entry_symbol(&self) -> &str {
        &self.compiled.entry_symbol
    }

    /// Get the number of dependencies.
    pub fn dep_count(&self) -> usize {
        self.dep_count
    }

    /// Get the cell name.
    pub fn name(&self) -> &str {
        &self.compiled.name
    }
}
